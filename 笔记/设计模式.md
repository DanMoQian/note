# 设计模式

## 原型设计模式

反例：

```java
//周报
class WeekReport {
    private String name;
    private String summer;
    private String plan;
    private String suggest;
    private Date time;
    //getter setter toString省略
}
```

> 在创建对象实例需要对成员进行赋值，但是当参数过多且某些参数不会经常发生变动，就特别麻烦。可以使用原型模式来解决

正例：

```java
class WeekReport implements Cloneable{
    private String name;
    private String summer;
    private String plan;
    private String suggest;
    private Date time;
    //getter setter toString省略
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
class Single implements Cloneable{
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}

public class AppTest {
    public static void main(String[] args) {

        WeekReport weekReport = new WeekReport();
        weekReport.setName("zhangsan");
        weekReport.setPlan("完成业务");
        weekReport.setSummer("完成草稿");
        weekReport.setSuggest("无");
        weekReport.setTime(new Date());
        System.out.println(weekReport);
        WeekReport weekReport1 = null;
        try {
            weekReport1 = (WeekReport) weekReport.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
        weekReport1.setSummer("完成任务");
        weekReport1.setPlan("完成测试");
        System.out.println(weekReport1);
        //比较地址
        System.out.println(weekReport == weekReport1);
    }
}
```

> 原型模式
>
> 1. 将类实现克隆接口，该类没有用任何抽象方法，该接口仅仅是一个标记接口，作用是告诉jvm，任何实现了该cloneable接口的类对象，可以被克隆！
>
> 2. 必须重写object的本地clone方法，因为是该类实现clone，不重写就相当于调用了该类的object父类方法，而该方法是protected修饰的，被保护的
> 3. 调用克隆方法不会调用构造函数，可以破坏单例模式。直接复制到内存中（栈内存中、为什么不在堆内存中？去看逃逸分析）的二进制，效率更高。所以和原先的对象地址不一致，最终是两个不同空间中

### 浅克隆

重写的clone调用的是父类的本地clone方法，使用的是浅克隆



![yoMNBDwQrHCSVPv](C:\Users\DMQi\Desktop\yoMNBDwQrHCSVPv.png)

### 深克隆

- 方案一：克隆引用

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    WeekReport clone = (WeekReport) super.clone();
    Date timeClone = (Date) clone.getTime().clone();
    clone.setTime(timeClone);
    return clone;
}
```

- 方案二：使用序列化流

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    /*WeekReport clone = (WeekReport) super.clone();*/
    /*Date timeClone = (Date) clone.getTime().clone();
    clone.setTime(timeClone);*/
    Object clone = null;
    try {
        //写入硬盘中会存在不少问题 写死地址会存在跨平台问题
        OutputStream os = new FileOutputStream("D:\\a.txt");
        ObjectOutputStream oos = new ObjectOutputStream(os);
        oos.writeObject(this);

        InputStream is = new FileInputStream("D:\\a.txt");
        ObjectInputStream ois = new ObjectInputStream(is);
        clone = ois.readObject();

        os.close();
        oos.close();
        is.close();
        ois.close();


    } catch (Exception e) {
        e.printStackTrace();
    }
    return clone;
}
```

- 改善

```java
//使用ByteArrayOutputStream将对象写到内存中
ByteArrayOutputStream baos = new ByteArrayOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(baos);
oos.writeObject(this);

byte[] bytes = baos.toByteArray();

InputStream is = new ByteArrayInputStream(bytes);
ObjectInputStream ois = new ObjectInputStream(is);
clone = ois.readObject();

baos.close();
oos.close();
is.close();
ois.close();
```



# Java创建对象的四种方式

> new 调用构造器
>
> 反射机制
>
> 反序列化
>
> 克隆